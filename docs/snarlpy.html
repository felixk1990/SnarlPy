
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>snarlpy modules &#8212; snarlpy  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">snarlpy  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">snarlpy modules</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="snarlpy-modules">
<h1>snarlpy modules<a class="headerlink" href="#snarlpy-modules" title="Permalink to this heading">¶</a></h1>
<section id="module-snarlpy.cycle_sampling">
<span id="snarlpy-cycle-sampling"></span><h2>snarlpy.cycle_sampling<a class="headerlink" href="#module-snarlpy.cycle_sampling" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.generate_networkx_cycle_from_edges">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">generate_networkx_cycle_from_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#generate_networkx_cycle_from_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.generate_networkx_cycle_from_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate networkx.Graph object representing a basis cycle from a given
edge subset.</p>
<dl>
<dt>Args:</dt><dd><p>edge_set (list):</p>
<blockquote>
<div><p>The binary edge vector representing the cycle.</p>
</div></blockquote>
<p>input_graph (networkx.Graph):</p>
<blockquote>
<div><p>The original simple graph used for reduction.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>networkx.Graph:</p>
<blockquote>
<div><p>A simple eulerian cycle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.generate_random_coordinate">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">generate_random_coordinate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nullity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#generate_random_coordinate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.generate_random_coordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a binary sequence vector of length ‘nullity’.</p>
<dl>
<dt>Args:</dt><dd><p>nullity (int):</p>
<blockquote>
<div><p>The cyclomatic number determining the length of the binary vector.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A binary vector for cycle sampling from a set of cardinality
‘nullity’.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.generate_random_index">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">generate_random_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nullity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#generate_random_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.generate_random_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an index vector for sampling from a cycle basis of cardinality
‘nullity’.</p>
<dl>
<dt>Args:</dt><dd><p>nullity (int):</p>
<blockquote>
<div><p>The cyclomatic number determining the length of the binary vector.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>An index vector for cycle sampling from a set of cardinality
‘nullity’.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.get_binary">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">get_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#get_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.get_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a binary sequence vector of length a.</p>
<dl>
<dt>Args:</dt><dd><p>j (int):</p>
<blockquote>
<div><p>The j-th binary to generate.</p>
</div></blockquote>
<p>a (int):</p>
<blockquote>
<div><p>The cyclomatic number deterining the vector length/scope.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A binary vector for further cycle sampling processes.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.get_keyNumbers_forBinary">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">get_keyNumbers_forBinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">null</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#get_keyNumbers_forBinary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.get_keyNumbers_forBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a random index from the cycle space of a graph with nullity ‘null’.
Args:</p>
<blockquote>
<div><p>null (int):</p>
<blockquote>
<div><p>The cyclomatic number determining the the exponential size of
the cycle space.</p>
</div></blockquote>
<p>iteration (int):</p>
<blockquote>
<div><p>Sample size.</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>Returns:</dt><dd><p>iterable:</p>
<blockquote>
<div><p>An index vector for cycle sampling from a set of basis cardinality
‘null’.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.get_new_cycle">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">get_new_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backbone_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#get_new_cycle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.get_new_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a new networkx.Graph object, representing a cycle from a given
graph, its cycle basis and a binary coefficient vector.</p>
<dl>
<dt>Args:</dt><dd><p>new_key (int):</p>
<blockquote>
<div><p>The binary coefficient vectorto generate a cycle superpostion.</p>
</div></blockquote>
<p>cycle_matrix (int):</p>
<blockquote>
<div><p>The graph’s mesh matrix for a given cycle basis.</p>
</div></blockquote>
<p>backbone_graph (int):</p>
<blockquote>
<div><p>The input graph used to reconstruct a full networkx.Graph object</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>networkx.Graph:</p>
<blockquote>
<div><p>A simple eulerian cycle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.get_new_cycle_components">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">get_new_cycle_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx_cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backbone_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#get_new_cycle_components"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.get_new_cycle_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a new networkx.Graph object, representing a cycle from a given
graph, its cycle basis and a binary coefficient vector.</p>
<dl>
<dt>Args:</dt><dd><p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
<p>edge_matrix (list):</p>
<blockquote>
<div><p>The binary mesh matrix of the graph.</p>
</div></blockquote>
<p>nx_cycle (networkx.Graph):</p>
<blockquote>
<div><p>The networx.Graph object representing a Eulerian cycle.</p>
</div></blockquote>
<p>backbone_graph (networkx.Graph):</p>
<blockquote>
<div><p>The original simple graph used for reduction.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarray:</p>
<blockquote>
<div><p>The coefficient vector for given cycle in the current
cycle basis.</p>
</div></blockquote>
<p>networkx.Graph:</p>
<blockquote>
<div><p>The rebuild of the given Eulerian cycle for simplification.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.get_new_cycle_components_gamma">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">get_new_cycle_components_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backbone_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#get_new_cycle_components_gamma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.get_new_cycle_components_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a new networkx.Graph object, representing a cycle from a given
graph, its cycle basis and a binary coefficient vector.</p>
<dl>
<dt>Args:</dt><dd><p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
<p>edge_matrix (list):</p>
<blockquote>
<div><p>The binary mesh matrix of the graph.</p>
</div></blockquote>
<p>key (networkx.Graph):</p>
<blockquote>
<div><p>An index list indicating which cycles are to be superimposed.</p>
</div></blockquote>
<p>backbone_graph (networkx.Graph):</p>
<blockquote>
<div><p>The original simple graph used for reduction.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarray:</p>
<blockquote>
<div><p>The coefficient vector for given cycle in the current
cycle basis.</p>
</div></blockquote>
<p>networkx.Graph:</p>
<blockquote>
<div><p>The rebuild of the given Eulerian cycle for simplification.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.grab_all_cycles_from_space">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">grab_all_cycles_from_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#grab_all_cycles_from_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.grab_all_cycles_from_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and catch all cycle space coefficient vectors.
(CAREFUL CYCLE SPACES HAVE EXPONENTIAL COMPLEXITY, ONLY USE FOR SMALL
CYCLOMATIC NUMBERS)</p>
<dl>
<dt>Args:</dt><dd><p>args (list):</p>
<blockquote>
<div><p>A list of cyclomatic numbers.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>iterable:</p>
<blockquote>
<div><p>A list of binary vectors for further cycle sampling processes.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.cycle_sampling.grab_cycles_from_space">
<span class="sig-prename descclassname"><span class="pre">snarlpy.cycle_sampling.</span></span><span class="sig-name descname"><span class="pre">grab_cycles_from_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycle_sampling.html#grab_cycles_from_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycle_sampling.grab_cycles_from_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random cycle space coefficient vectors.</p>
<dl>
<dt>Args:</dt><dd><p>args (list):</p>
<blockquote>
<div><p>A list of cyclomatic numbers.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>iterable:</p>
<blockquote>
<div><p>A list of binary vectors for further cycle sampling processes.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-snarlpy.cycleToolsLinking">
<span id="snarlpy-cycletoolslinking"></span><h2>snarlpy.cycleToolsLinking<a class="headerlink" href="#module-snarlpy.cycleToolsLinking" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_extraTools">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">snarlpy.cycleToolsLinking.</span></span><span class="sig-name descname"><span class="pre">linkedCycles_extraTools</span></span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_extraTools"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_extraTools" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools" title="snarlpy.cycleToolsLinking.linkedCycles_tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">linkedCycles_tools</span></code></a></p>
<p>A class f function tools to compte linking of cycle basis of simple,
spatially embedded graphs.
Attributes:</p>
<blockquote>
<div><p>tck (dict):</p>
<blockquote>
<div><p>Spline parameters for curve smoothening</p>
</div></blockquote>
<p>edge_res (int):</p>
<blockquote>
<div><p>Edge point resolution.</p>
</div></blockquote>
<p>XS (list):</p>
<blockquote>
<div><p>Array of curve parameters (0,1) for edge point densification.</p>
</div></blockquote>
<p>N (int):</p>
<blockquote>
<div><p>???</p>
</div></blockquote>
<p>res (int):</p>
<blockquote>
<div><p>Numeric resoltuion of Gauss map (double integral) evaluation.</p>
</div></blockquote>
<p>threshold (float):</p>
<blockquote>
<div><p>Linkage number demanded accuracy.</p>
</div></blockquote>
<p>limit (int):</p>
<blockquote>
<div><p>Internal limit numbers.</p>
</div></blockquote>
<p>lm (list):</p>
<blockquote>
<div><p>List of internal limit numbers.</p>
</div></blockquote>
<p>itvl (list):</p>
<blockquote>
<div><p>Double integral borders.</p>
</div></blockquote>
<p>x (list):</p>
<blockquote>
<div><p>An array holding curve parameters for smoothened curves.</p>
</div></blockquote>
<p>dxy (float):</p>
<blockquote>
<div><p>Double integral infinitesimal square factor.</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Methods:</dt><dd><dl class="simple">
<dt>__post_init__()</dt><dd><p>The model post_init function.</p>
</dd>
<dt>calc_linkage_cycleSets_nxGraph(cycle_sets1, cycle_sets2)</dt><dd><p>Compute the linkage dictionaries in boolean and numeric form for
two sets of cycle bases (in networkx format).</p>
</dd>
<dt>extract_points_nxGraph(cycle_sets1, cycle_sets2)</dt><dd><p>Extract the polygonial representation of each edge of the given
graph sets.</p>
</dd>
<dt>calc_linkage_cycleSets_points3D(curves_set1, curves_set2)</dt><dd><p>Compute the linkage dictionaries in boolean and numeric form for
two sets of cycle bases (in polygonial format).</p>
</dd>
<dt>calc_linkage_points3D(curves_set1, curves_set2)</dt><dd><p>Compute the linkage of polygonial curves in 3D via the Gauss map
for each cycle pairing.</p>
</dd>
<dt>get_geoInfo(curve_sets)</dt><dd><p>Compute cycle centers and maximal point distance from center (For
pre-sorting spatially distant cycles which cant’possibly be linked)</p>
</dd>
<dt>compute_link_number(curve1, curve2):</dt><dd><p>Compute the specific link for a pair of curves, via Gauss map
evaluation.</p>
</dd>
<dt>get_smooth_curve(points3D)</dt><dd><p>Smoothing of polygonial curves in order to improve results for
sharp bending points and fourther function generator dependencies.</p>
</dd>
<dt>refine_curve_points(points3D)</dt><dd><p>Increase point density of the graph’sedges, by inserting extra
points along the line segments.</p>
</dd>
<dt>get_smooth_points(t, tck)</dt><dd><p>Create a smooth 3D point representation by utilizing previoulsy
calucalted spline parameters and current curve parameters.</p>
</dd>
<dt>get_smooth_director(t, tck):</dt><dd><p>Create a smooth 3D point representation of the curves tangent by
utilizing previoulsy calucalted spline parameters and current curve
parameters.</p>
</dd>
<dt>gauss_map(points, tangents)</dt><dd><p>Gauss map evaluation utilizing the entirety of curve points and
their tangents (equal to entire double integral kernel evaluation).</p>
</dd>
<dt>compute_link_number(curve1, curve2)</dt><dd><p>Compute the linking number of two closed curves
(3D point representation).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_extraTools.compute_link_number">
<span class="sig-name descname"><span class="pre">compute_link_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curve1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curve2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_extraTools.compute_link_number"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_extraTools.compute_link_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linking number of two closed curves
(3D point representation).</p>
<dl>
<dt>Args:</dt><dd><p>curve_1 (list):</p>
<blockquote>
<div><p>A list of 3D-point sets representing a cycle
of graph #1.</p>
</div></blockquote>
<p>curve_2 (list):</p>
<blockquote>
<div><p>A list of 3D-point sets representing a cycle
of graph #2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary containing the numeric value of the linking number
integral (Gauss map).</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_extraTools.gauss_map">
<span class="sig-name descname"><span class="pre">gauss_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_extraTools.gauss_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_extraTools.gauss_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Gauss mappiecewise linear bits of the entire closed super-curves.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>x1 (float):</dt><dd><p>Curve parameter #1.</p>
</dd>
<dt>x2 (float):</dt><dd><p>Curve parameter #2.</p>
</dd>
<dt>p12 (ndarray):</dt><dd><p>Anchor point difference.</p>
</dd>
<dt>t (list):</dt><dd><p>A list of ndarrays representing the current edge tangent
vector.</p>
</dd>
<dt>p12 (ndarray):</dt><dd><p>Anchor point difference.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>float:</p>
<blockquote>
<div><p>The evaluated, non-rounded value of the Gauss map kernel bit.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">snarlpy.cycleToolsLinking.</span></span><span class="sig-name descname"><span class="pre">linkedCycles_tools</span></span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles" title="snarlpy.simpleCycles.simple_cycles"><code class="xref py py-class docutils literal notranslate"><span class="pre">simple_cycles</span></code></a></p>
<p>A class f function tools to compte linking of cycle basis of simple,
spatially embedded graphs.
Attributes:</p>
<blockquote>
<div><p>tck (dict):</p>
<blockquote>
<div><p>Spline parameters for curve smoothening</p>
</div></blockquote>
<p>edge_res (int):</p>
<blockquote>
<div><p>Edge point resolution.</p>
</div></blockquote>
<p>XS (list):</p>
<blockquote>
<div><p>Array of curve parameters (0,1) for edge point densification.</p>
</div></blockquote>
<p>N (int):</p>
<blockquote>
<div><p>???</p>
</div></blockquote>
<p>res (int):</p>
<blockquote>
<div><p>Numeric resoltuion of Gauss map (double integral) evaluation.</p>
</div></blockquote>
<p>threshold (float):</p>
<blockquote>
<div><p>Linkage number demanded accuracy.</p>
</div></blockquote>
<p>x (list):</p>
<blockquote>
<div><p>An array holding curve parameters for smoothened curves.</p>
</div></blockquote>
<p>dxy (float):</p>
<blockquote>
<div><p>Double integral infinitesimal square factor.</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Methods:</dt><dd><dl class="simple">
<dt>__post_init__()</dt><dd><p>The model post_init function.</p>
</dd>
<dt>calc_linkage_cycleSets_nxGraph(cycle_sets1, cycle_sets2)</dt><dd><p>Compute the linkage dictionaries in boolean and numeric form for
two sets of cycle bases (in networkx format).</p>
</dd>
<dt>extract_points_nxGraph(cycle_sets1, cycle_sets2)</dt><dd><p>Extract the polygonial representation of each edge of the given
graph sets.</p>
</dd>
<dt>calc_linkage_cycleSets_points3D(curves_set1, curves_set2)</dt><dd><p>Compute the linkage dictionaries in boolean and numeric form for
two sets of cycle bases (in polygonial format).</p>
</dd>
<dt>calc_linkage_points3D(curves_set1, curves_set2)</dt><dd><p>Compute the linkage of polygonial curves in 3D via the Gauss map
for each cycle pairing.</p>
</dd>
<dt>get_geoInfo(curve_sets)</dt><dd><p>Compute cycle centers and maximal point distance from center (For
pre-sorting spatially distant cycles which cant’possibly be linked)</p>
</dd>
<dt>compute_link_number(curve1, curve2):</dt><dd><p>Compute the specific link for a pair of curves, via Gauss map
evaluation.</p>
</dd>
<dt>get_smooth_curve(points3D)</dt><dd><p>Smoothing of polygonial curves in order to improve results for
sharp bending points and fourther function generator dependencies.</p>
</dd>
<dt>refine_curve_points(points3D)</dt><dd><p>Increase point density of the graph’sedges, by inserting extra
points along the line segments.</p>
</dd>
<dt>get_smooth_points(t, tck)</dt><dd><p>Create a smooth 3D point representation by utilizing previoulsy
calucalted spline parameters and current curve parameters.</p>
</dd>
<dt>get_smooth_director(t, tck):</dt><dd><p>Create a smooth 3D point representation of the curves tangent by
utilizing previoulsy calucalted spline parameters and current curve
parameters.</p>
</dd>
<dt>gauss_map(points, tangents)</dt><dd><p>Gauss map evaluation utilizing the entirety of curve points and
their tangents (equal to entire double integral kernel evaluation).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_cycleSets_nxGraph">
<span class="sig-name descname"><span class="pre">calc_linkage_cycleSets_nxGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_sets1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle_sets2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.calc_linkage_cycleSets_nxGraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_cycleSets_nxGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linkage dictionaries in boolean and numeric form for two
sets of cycle bases (in networkx format).</p>
<dl>
<dt>Args:</dt><dd><p>cycle_sets1 (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects representing the cycle basis
of graph #1.</p>
</div></blockquote>
<p>cycle_sets2 (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects representing the cycle basis
of graph #2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary containing the boolean value of linkage for each
cycle pair of the input bases.</p>
</div></blockquote>
<p>dict:</p>
<blockquote>
<div><p>A dictionary containing the numeric value of linkage (Gauss
map) for each cycle pair of the input bases.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_cycleSets_points3D">
<span class="sig-name descname"><span class="pre">calc_linkage_cycleSets_points3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curves_set1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curves_set2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.calc_linkage_cycleSets_points3D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_cycleSets_points3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linkage dictionaries in boolean and numeric form for two
sets of cycle bases (in polygonial format).</p>
<dl>
<dt>Args:</dt><dd><p>cycle_sets1 (list):</p>
<blockquote>
<div><p>A list of 3D-point sets representing the cycle basis
of graph #1.</p>
</div></blockquote>
<p>cycle_sets2 (list):</p>
<blockquote>
<div><p>A list of 3D-point sets representing the cycle basis
of graph #2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary containing the boolean value of linkage for each
cycle pair of the input bases.</p>
</div></blockquote>
<p>dict:</p>
<blockquote>
<div><p>A dictionary containing the numeric value of linkage (Gauss
map) for each cycle pair of the input bases.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_points3D">
<span class="sig-name descname"><span class="pre">calc_linkage_points3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curves_set1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curves_set2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.calc_linkage_points3D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_points3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linkage of polygonial curves in 3D via the Gauss map for
each cycle pairing.</p>
<dl>
<dt>Args:</dt><dd><p>cycle_sets1 (list):</p>
<blockquote>
<div><p>A list of 3D-point sets representing the cycle basis
of graph #1.</p>
</div></blockquote>
<p>cycle_sets2 (list):</p>
<blockquote>
<div><p>A list of 3D-point sets representing the cycle basis
of graph #2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary containing the numeric value of linkage (Gauss
map) for each cycle pair of the input bases.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.compute_link_number">
<span class="sig-name descname"><span class="pre">compute_link_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curve1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curve2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.compute_link_number"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.compute_link_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the specific link for a pair of curves, via Gauss map
evaluation.</p>
<dl>
<dt>Args:</dt><dd><p>curve_1 (list):</p>
<blockquote>
<div><p>A list 3D points (ordered) forming a closed curve (cycle #1).</p>
</div></blockquote>
<p>curve_1 (list):</p>
<blockquote>
<div><p>A list 3D points (ordered) forming a closed curve (cycle #2).</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>float:</p>
<blockquote>
<div><p>Non-rounded result of numeric double integral evaluation.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.extract_points_nxGraph">
<span class="sig-name descname"><span class="pre">extract_points_nxGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_sets1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle_sets2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.extract_points_nxGraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.extract_points_nxGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the polygonial representation of each edge of the given graph
sets.</p>
<dl>
<dt>Args:</dt><dd><p>cycle_sets1 (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects representing the cycle basis
of graph #1.</p>
</div></blockquote>
<p>cycle_sets2 (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects representing the cycle basis
of graph #2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of polygons for each input basis representing the
spatially embeded curve for each basis cycle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.gauss_map">
<span class="sig-name descname"><span class="pre">gauss_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.gauss_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.gauss_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Gauss map evaluation utilizing the entirety of curve points and their
tangents (equal to entire double integral kernel evaluation).</p>
<dl>
<dt>Args:</dt><dd><p>points (list):</p>
<blockquote>
<div><p>A list of 3D points as part of the smooth curve representation,
for each cyce.</p>
</div></blockquote>
<p>tangents (tuple):</p>
<blockquote>
<div><p>A list 3D points as part of the smooth curve representation,
for each cycle.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>float:</p>
<blockquote>
<div><p>The evaluated, non-rounded value of the Gauss map kernel.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.get_geoInfo">
<span class="sig-name descname"><span class="pre">get_geoInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curve_sets</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.get_geoInfo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_geoInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cycle centers and maximal point distance from center (For
pre-sorting spatially distant cycles which cant’possibly be linked)</p>
<dl>
<dt>Args:</dt><dd><p>curve_sets (list):</p>
<blockquote>
<div><p>A list of polygons for each input basis representing the
spatially embeded curve for each basis cycle.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary containing cycle centers for each cycle basis
(3D points)</p>
</div></blockquote>
<p>dict:</p>
<blockquote>
<div><p>A dictionary containing maximal point distance from the center
for each cycle basis.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_curve">
<span class="sig-name descname"><span class="pre">get_smooth_curve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points3D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.get_smooth_curve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothing of polygonial curves in order to improve results for sharp
bending points and fourther function generator dependencies.</p>
<dl>
<dt>Args:</dt><dd><p>points3D (list):</p>
<blockquote>
<div><p>A list 3D points (ordered) forming a closed curve.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>tuple:</p>
<blockquote>
<div><p>(t,c,k) a tuple containing the vector of knots, the B-spline
coefficients, and the degree of the spline.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_director">
<span class="sig-name descname"><span class="pre">get_smooth_director</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tck</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.get_smooth_director"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_director" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a smooth 3D point representation of the curves tangent by
utilizing previoulsy calucalted spline parameters and current curve
parameters.</p>
<dl>
<dt>Args:</dt><dd><p>t (list):</p>
<blockquote>
<div><p>Current curve parameter.</p>
</div></blockquote>
<p>tck (tuple):</p>
<blockquote>
<div><p>(t,c,k) a tuple containing the vector of knots, the B-spline
coefficients, and the degree of the spline.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarrray:</p>
<blockquote>
<div><p>A 3D point as part of the smooth curve representation.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_points">
<span class="sig-name descname"><span class="pre">get_smooth_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tck</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.get_smooth_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a smooth 3D point representation by utilizing previoulsy
calucalted spline parameters and current curve parameters.</p>
<dl>
<dt>Args:</dt><dd><p>t (list):</p>
<blockquote>
<div><p>Current curve parameter.</p>
</div></blockquote>
<p>tck (tuple):</p>
<blockquote>
<div><p>(t,c,k) a tuple containing the vector of knots, the B-spline
coefficients, and the degree of the spline.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarrray:</p>
<blockquote>
<div><p>A 3D point as part of the smooth curve representation.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.cycleToolsLinking.linkedCycles_tools.refine_curve_points">
<span class="sig-name descname"><span class="pre">refine_curve_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points3D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/cycleToolsLinking.html#linkedCycles_tools.refine_curve_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.refine_curve_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase point density of the graph’sedges, by inserting extra points
along the line segments.</p>
<dl>
<dt>Args:</dt><dd><p>points3D (list):</p>
<blockquote>
<div><p>A list 3D points (ordered) forming a closed curve, each
consecutive tuple represents an edge from the graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>Denser 3D point representation of closed curves.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-snarlpy.edge_algebra">
<span id="snarlpy-edge-algebra"></span><h2>snarlpy.edge_algebra<a class="headerlink" href="#module-snarlpy.edge_algebra" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.calc_echelon_form">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">calc_echelon_form</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ax</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#calc_echelon_form"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.calc_echelon_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the echelon form of a given binary equations system and checking
for inconsistencies and solutions of the key problem.</p>
<dl>
<dt>Args:</dt><dd><p>Ax (ndarray):</p>
<blockquote>
<div><p>A given binary equation system, used for linear independence tests
of Eulerian cycles.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarray:</p>
<blockquote>
<div><p>The last column of the echelon, indicating whether the column
vectors are linear independent or not.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.check_superposition_edge_connected">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">check_superposition_edge_connected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#check_superposition_edge_connected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.check_superposition_edge_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cycle superpostion with consectuive test whether the cycles
generated during superposition are connected.</p>
<dl>
<dt>Args:</dt><dd><p>keys (list):</p>
<blockquote>
<div><p>An index list indicating which cycles are to be superimposed.</p>
</div></blockquote>
<p>cycle_matrix (ndarray):</p>
<blockquote>
<div><p>The binary edge vectors of all cycles bundled into one
matrix (technically the graph’s mesh matrix).</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>bool:</p>
<blockquote>
<div><p>True or False, depending on whether the cycles
generated during superposition are connected.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.edge_column">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">edge_column</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#edge_column"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.edge_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the signature-sensitive edge vector representation of a given
cycle.</p>
<dl>
<dt>Args:</dt><dd><p>c (networkx.Graph):</p>
<blockquote>
<div><p>A networkx.Graph representing a Eulerian cycle in the simple
graph.</p>
</div></blockquote>
<p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
<p>sig_graph (dict):</p>
<blockquote>
<div><p>A dictionary holding the information on the graph’s intrinsic
edge signatures (directions) for comparison with cycle edge
directions.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nadarray:</p>
<blockquote>
<div><p>The signature-sensitive edge vector representation of the given
cycle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.edge_column_binary">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">edge_column_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#edge_column_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.edge_column_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the binary edge vector representation of a given
cycle.</p>
<dl>
<dt>Args:</dt><dd><p>c (networkx.Graph):</p>
<blockquote>
<div><p>A networkx.Graph representing a Eulerian cycle in the simple
Graph.</p>
</div></blockquote>
<p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nadarray:</p>
<blockquote>
<div><p>The binary edge vector representation of the given
cycle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.edge_column_rand">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">edge_column_rand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#edge_column_rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.edge_column_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the signature-sensitive edge vector representation of a given
cycle. Randomize the initial node for the ycle’s signature computation.</p>
<dl>
<dt>Args:</dt><dd><p>c (networkx.Graph):</p>
<blockquote>
<div><p>A networkx.Graph representing a Eulerian cycle in the simple
graph.</p>
</div></blockquote>
<p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
<p>sig_graph (dict):</p>
<blockquote>
<div><p>A dictionary holding the information on the graph’s intrinsic
edge signatures (directions) for comparison with cycle edge
directions.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nadarray:</p>
<blockquote>
<div><p>The signature-sensitive edge vector representation of the given
cycle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.generate_edge_matrix">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">generate_edge_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#generate_edge_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.generate_edge_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the signature-sensitive edge vector representations of an entire
cycle basis.</p>
<dl>
<dt>Args:</dt><dd><p>basis (list):</p>
<blockquote>
<div><p>A list networkx.Graph objects, representing the Eulerian cycle
basis of the simple graph.</p>
</div></blockquote>
<p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
<p>sig_graph (dict):</p>
<blockquote>
<div><p>A dictionary holding the information on the graph’s intrinsic
edge signatures (directions) for comparison with cycle edge
directions.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nadarray:</p>
<blockquote>
<div><p>The signature-sensitive edge vectors of all cycles bundled into one
matrix (technically the graph’s mesh matrix)</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.generate_edge_matrix_binary">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">generate_edge_matrix_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#generate_edge_matrix_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.generate_edge_matrix_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the binary edge vector representations of an entire
cycle basis.</p>
<dl>
<dt>Args:</dt><dd><p>basis (list):</p>
<blockquote>
<div><p>A list networkx.Graph objects, representing the Eulerian cycle
basis of the simple graph.</p>
</div></blockquote>
<p>edge_set (list):</p>
<blockquote>
<div><p>A list of all edges in the simple graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nadarray:</p>
<blockquote>
<div><p>The binary edge vectors of all cycles bundled into one
matrix (technically the graph’s mesh matrix).</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.get_component_key">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">get_component_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#get_component_key"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.get_component_key" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given binary edge vector, compute its coefficient vector
with respect to the currently used basis.</p>
<dl>
<dt>Args:</dt><dd><p>edge_vector (ndarray):</p>
<blockquote>
<div><p>The binary edge vector presentation of an Eulerian cycle.</p>
</div></blockquote>
<p>edge_matrix (ndarray):</p>
<blockquote>
<div><p>The simple graph’s mesh matrix, representing the set of basis
cycles.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarray:</p>
<blockquote>
<div><p>The coefficient vector for given cycle in the current
cycle basis.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.get_cycle_superpositions_edge_vector">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">get_cycle_superpositions_edge_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#get_cycle_superpositions_edge_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.get_cycle_superpositions_edge_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge vector of a cycle aquired from superposition of basis
cycles.</p>
<dl>
<dt>Args:</dt><dd><p>keys (list):</p>
<blockquote>
<div><p>An index list indicating which cycles are to be superimposed.</p>
</div></blockquote>
<p>cycle_matrix (ndarray):</p>
<blockquote>
<div><p>The binary edge vectors of all cycles bundled into one
matrix (technically the graph’s mesh matrix).</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nadarray:</p>
<blockquote>
<div><p>The signature-sensitive edge vectors of all cycles bundled into one
matrix (technically the graph’s mesh matrix)</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.edge_algebra.sort_rows">
<span class="sig-prename descclassname"><span class="pre">snarlpy.edge_algebra.</span></span><span class="sig-name descname"><span class="pre">sort_rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ax</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/edge_algebra.html#sort_rows"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.edge_algebra.sort_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Resort rows, as part of acquiring the echelon form of the linear system Ax.</p>
<dl>
<dt>Args:</dt><dd><p>column (ndarray):</p>
<blockquote>
<div><p>Current column index being processed.</p>
</div></blockquote>
<p>idx (ndarray):</p>
<blockquote>
<div><p>The current row processed that needs to be shifted.</p>
</div></blockquote>
<p>Ax (ndarray):</p>
<blockquote>
<div><p>A given binary equation system, used for linear independence tests
of Eulerian cycles.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-snarlpy.edgePriority">
<span id="snarlpy-edgepriority"></span><h2>snarlpy.edgePriority<a class="headerlink" href="#module-snarlpy.edgePriority" title="Permalink to this heading">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">members<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">show-inheritance<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
</dl>
</section>
<section id="snarlpy-edgeprioritycoarsesystem">
<h2>snarlpy.edgePriorityCoarseSystem<a class="headerlink" href="#snarlpy-edgeprioritycoarsesystem" title="Permalink to this heading">¶</a></h2>
</section>
<section id="snarlpy-snarlpyness-randrobustness">
<h2>snarlpy.snarlpyness_randRobustness<a class="headerlink" href="#snarlpy-snarlpyness-randrobustness" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-snarlpy.sampling">
<span id="snarlpy-sampling"></span><h2>snarlpy.sampling<a class="headerlink" href="#module-snarlpy.sampling" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.calc_basisIntertwinedness">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">calc_basisIntertwinedness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph_sets</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#calc_basisIntertwinedness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.calc_basisIntertwinedness" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the first intertwinedness metrics (linkage matrices for arbitrary
cycle bases).</p>
<dl>
<dt>Args:</dt><dd><p>grap_sets (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects which posses a defined spatial
embedding (nodal pos-attributes).</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of the arbitrarily chosen cycle matrix for the graphs.</p>
</div></blockquote>
<p>ndarray:</p>
<blockquote>
<div><p>The linkage matrix of the graph set.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.calc_basis_linkage">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">calc_basis_linkage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_sets1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle_sets2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#calc_basis_linkage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.calc_basis_linkage" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linkage dictionary for each cycle pair.</p>
<dl>
<dt>Args:</dt><dd><p>cycle_sets1 (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects, represting the basis cycles of
the input graph #1.</p>
</div></blockquote>
<p>cycle_sets2 (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects, represting the basis cycles of
the input graph #2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>The linkage dictionary, contaitning the non-rounded results of the
Gauss-Map calculations for each cycle pair.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.calc_cycle_basis">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">calc_cycle_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#calc_cycle_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.calc_cycle_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a cycle basis of a simple graph via a bfs search algorithm.</p>
<dl>
<dt>Args:</dt><dd><p>nx_graph (networkx.Graph):</p>
<blockquote>
<div><p>A simple graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of networkx.Graph objeccts, represting the basis cycles of
the input graph.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.calc_cycle_minimum_basis">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">calc_cycle_minimum_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#calc_cycle_minimum_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.calc_cycle_minimum_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a minimal topological cycle basis of a simple graph via Horton’s
algorithm.</p>
<dl>
<dt>Args:</dt><dd><p>nx_graph (networkx.Graph):</p>
<blockquote>
<div><p>A simple graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of networkx.Graph objects, represting the basis cycles of
the input graph.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.calc_nullity">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">calc_nullity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#calc_nullity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.calc_nullity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a simple graph’s nullity/cyclomatic number.</p>
<dl>
<dt>Args:</dt><dd><p>G (networkx.Graph):</p>
<blockquote>
<div><p>A simple graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>int:</p>
<blockquote>
<div><p>The cyclomatic number of the graph.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.extract_linkage_matrix">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">extract_linkage_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numeric_res</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#extract_linkage_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.extract_linkage_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linkage matrix from raw, non-rounded resuts dict structure.</p>
<dl>
<dt>Args:</dt><dd><p>numeric_res (networkx.Graph):</p>
<blockquote>
<div><p>The linkage dictionary, contaitning the non-rounded results of the
Gauss-Map calculations for each cycle pair.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarray:</p>
<blockquote>
<div><p>The linkage matrix of two graphs in cycle per cycle representation.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.sampling.get_basis_matrices">
<span class="sig-prename descclassname"><span class="pre">snarlpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_basis_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graphs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyc_nx_base</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/sampling.html#get_basis_matrices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.sampling.get_basis_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute auxillary matrix sets for further computation intertwinedness
metrics.</p>
<dl>
<dt>Args:</dt><dd><p>input_graphs (list):</p>
<blockquote>
<div><p>A list of networkx.Graph objects which posses a defined spatial
embedding (nodal pos-attributes).</p>
</div></blockquote>
<p>cyc_nx_base (list):</p>
<blockquote>
<div><p>A list of basis cycles for each graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of edge-tuples for each graph.</p>
</div></blockquote>
<p>list:</p>
<blockquote>
<div><p>The respective edge signatures for each graph.</p>
</div></blockquote>
<p>list:</p>
<blockquote>
<div><p>A list of (directed) mesh matrices for each graph.</p>
</div></blockquote>
<p>list:</p>
<blockquote>
<div><p>A list of (undirected) mesh matrices for each graph.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-snarlpy.signature">
<span id="snarlpy-signature"></span><h2>snarlpy.signature<a class="headerlink" href="#module-snarlpy.signature" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.signature.extract_eulerpath">
<span class="sig-prename descclassname"><span class="pre">snarlpy.signature.</span></span><span class="sig-name descname"><span class="pre">extract_eulerpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/signature.html#extract_eulerpath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.signature.extract_eulerpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the Eulerian path as an edge sequence from a cycle, given an
arbitrary starting node.</p>
<dl>
<dt>Args:</dt><dd><p>nx_cycle (networkx.Graph):</p>
<blockquote>
<div><p>A networkx.Graph object represeting a cycle.</p>
</div></blockquote>
<p>nroot (networkx.Graph.node):</p>
<blockquote>
<div><p>A networkx.Graph.node object to start the path search.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>iterable:</p>
<blockquote>
<div><p>A sequence of edges (ordered)/ a walk along the cyle.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.signature.get_edge_direction">
<span class="sig-prename descclassname"><span class="pre">snarlpy.signature.</span></span><span class="sig-name descname"><span class="pre">get_edge_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_set</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/signature.html#get_edge_direction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.signature.get_edge_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting the intrinsic direction for all edges in a given set.</p>
<dl>
<dt>Args:</dt><dd><p>edge-set (list):</p>
<blockquote>
<div><p>A set of edges, with aplha and omega nodes non-equal.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
set.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.signature.get_relative_direction">
<span class="sig-prename descclassname"><span class="pre">snarlpy.signature.</span></span><span class="sig-name descname"><span class="pre">get_relative_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/signature.html#get_relative_direction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.signature.get_relative_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Getting the edge signature for an edge set in relation to a reference set.</p>
<dl>
<dt>Args:</dt><dd><p>edge-set (list):</p>
<blockquote>
<div><p>A set of edges, with aplha and omega nodes non-equal.</p>
</div></blockquote>
<p>sig_grapht (dict):</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
reference graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
set.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.signature.get_signature">
<span class="sig-prename descclassname"><span class="pre">snarlpy.signature.</span></span><span class="sig-name descname"><span class="pre">get_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/signature.html#get_signature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.signature.get_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a simple graph for reference, compute the edge signatures for the
Eulerian path through the cycle.</p>
<dl>
<dt>Args:</dt><dd><p>nx_cycle (networkx.Graph):</p>
<blockquote>
<div><p>A networkx.Graph object represeting a cycle.</p>
</div></blockquote>
<p>sig_grapht (dict):</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
reference graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
cycle graph.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="snarlpy.signature.get_signature_rand">
<span class="sig-prename descclassname"><span class="pre">snarlpy.signature.</span></span><span class="sig-name descname"><span class="pre">get_signature_rand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig_graph</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/signature.html#get_signature_rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.signature.get_signature_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a simple graph for reference, compute the edge signatures for the
Eulerian path through the cycle. Randomize the root node during path
search.</p>
<dl>
<dt>Args:</dt><dd><p>nx_cycle (networkx.Graph):</p>
<blockquote>
<div><p>A networkx.Graph object represeting a cycle.</p>
</div></blockquote>
<p>sig_grapht (dict):</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
reference graph.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>dict:</p>
<blockquote>
<div><p>A dictionary holding the signature information for any edge in the
cycle graph.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-snarlpy.simpleCycles">
<span id="snarlpy-simplecycles"></span><h2>snarlpy.simpleCycles<a class="headerlink" href="#module-snarlpy.simpleCycles" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">snarlpy.simpleCycles.</span></span><span class="sig-name descname"><span class="pre">simple_cycles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to generate cycle bases and create a minimal basis in
networkx formats</p>
<section id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>G<span class="classifier">nx.Graph()</span></dt><dd><p>A simple graph which on which the cycle basis is calcuclated</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.breadth_first_tree">
<span class="sig-name descname"><span class="pre">breadth_first_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.breadth_first_tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.breadth_first_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a bfs-tree from root, as well a dictionary of shortest paths
between branching points and leaves.</p>
<dl>
<dt>Args:</dt><dd><p>root (int):</p>
<blockquote>
<div><p>The root vertex for bfs search.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>nx.Graph:</p>
<blockquote>
<div><p>The spanning tree from bfs search</p>
</div></blockquote>
<p>dictionary:</p>
<blockquote>
<div><p>A dicitonary of shortest paths between branching points and
leaves.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.compute_cycles_superlist">
<span class="sig-name descname"><span class="pre">compute_cycles_superlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.compute_cycles_superlist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.compute_cycles_superlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge list of cycles drawn from a Horton cycle search for
one vertex.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>root (int): The root vertex of the current bfs tree</p>
</dd>
<dt>Returns:</dt><dd><p>list: The superlist of cycles from all bfs trees, in edge list
representation</p>
</dd>
<dt>Raises:</dt><dd><p>Exception: description</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.compute_linear_independence">
<span class="sig-name descname"><span class="pre">compute_linear_independence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.compute_linear_independence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.compute_linear_independence" title="Permalink to this definition">¶</a></dt>
<dd><p>Return bool whether all columns of E are linear independent in Z2.</p>
<dl>
<dt>Args:</dt><dd><p>edge_mat (ndarray):</p>
<blockquote>
<div><p>An ndarray representing a binary cycle matrix in Z2.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>bool:</p>
<blockquote>
<div><p>Result indicating whether the columns are linear independent.</p>
</div></blockquote>
</dd>
<dt>Raises:</dt><dd><p>Exception: description</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.compute_sprouts">
<span class="sig-name descname"><span class="pre">compute_sprouts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">push_down</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">queue</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.compute_sprouts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.compute_sprouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Update bfs push list and tree structure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.construct_minimum_basis">
<span class="sig-name descname"><span class="pre">construct_minimum_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.construct_minimum_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.construct_minimum_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cycle basis for the input graph, with all elements
edge lists.</p>
<dl>
<dt>Args:</dt><dd><p>input_graph (nx.Graph):</p>
<blockquote>
<div><p>A networkx graph</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>The minimal basis of the graph, represented by a list of edge
lists.</p>
</div></blockquote>
</dd>
<dt>Raises:</dt><dd><p>Exception: description</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.construct_networkx_basis">
<span class="sig-name descname"><span class="pre">construct_networkx_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.construct_networkx_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.construct_networkx_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cycle basis for the input graph, with all elements
edge lists.</p>
<dl>
<dt>Args:</dt><dd><p>input_graph (nx.Graph):</p>
<blockquote>
<div><p>A networkx graph with ‘many’ cycles</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>The basis of the graph, represented by a list of networkx
graphs.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.construct_networkx_minimum_basis">
<span class="sig-name descname"><span class="pre">construct_networkx_minimum_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.construct_networkx_minimum_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.construct_networkx_minimum_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum cycle basis for the input graph, with all elements
edge lists.</p>
<dl>
<dt>Args:</dt><dd><p>input_graph (nx.Graph):</p>
<blockquote>
<div><p>A networkx graph with ‘many’ cycles</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>The minimal basis of the graph, represented by a list of
networkx graphs.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.edge_matrix">
<span class="sig-name descname"><span class="pre">edge_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_cycle</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.edge_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.edge_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a binary matrix for operations on Z2, representing current
cycle candidates and a test cycle.</p>
<dl>
<dt>Args:</dt><dd><p>nx_edges (nx.Graph):</p>
<blockquote>
<div><p>A networkx graph backbone being rebuilt with cycle base edges</p>
</div></blockquote>
<p>minimum_label (list):</p>
<blockquote>
<div><p>The labels sorting the edges in the binary cycle matrix.</p>
</div></blockquote>
<p>new_cycle (list):</p>
<blockquote>
<div><p>A list of edges of the cycle to be tested.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>ndarray: Numpy array representing a binary cycle matrix in Z2.</p>
</dd>
<dt>Raises:</dt><dd><p>Exception: description</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.extract_path_origin">
<span class="sig-name descname"><span class="pre">extract_path_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.extract_path_origin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.extract_path_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return an oriented closed edge walk on a simple cycle.</p>
<dl>
<dt>Args:</dt><dd><p>cycle (nx.Graph):</p>
<blockquote>
<div><p>A networkx graph representing a simple Eulerian cycle.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of nodes, in order of the cyclic path.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.find_cycle">
<span class="sig-name descname"><span class="pre">find_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.find_cycle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.find_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge list, and node list for a cycle constructed from
spanning tree + additional edge.</p>
<dl>
<dt>Args:</dt><dd><p>dict_path (dictionary):</p>
<blockquote>
<div><p>A dictionary of shortest paths in the bfs tree</p>
</div></blockquote>
<p>e (tuple):</p>
<blockquote>
<div><p>The edge which is to be plugge into the bfs tree and generates
a cycle.</p>
</div></blockquote>
<p>n (int):</p>
<blockquote>
<div><p>The root of the current bfs tree</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>list:</p>
<blockquote>
<div><p>A list of vertices for the new cycle</p>
</div></blockquote>
<p>list:</p>
<blockquote>
<div><p>A list of edges for the new cycle</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snarlpy.simpleCycles.simple_cycles.generate_cycle_lists">
<span class="sig-name descname"><span class="pre">generate_cycle_lists</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/snarlpy/simpleCycles.html#simple_cycles.generate_cycle_lists"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#snarlpy.simpleCycles.simple_cycles.generate_cycle_lists" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge list, and labeled dictionary of cycles drawn from
a Horton cycle search for all vertices.</p>
<dl>
<dt>Returns:</dt><dd><p>dictionary:</p>
<blockquote>
<div><p>A dictionary which of cycles generated from bfs searches</p>
</div></blockquote>
<p>list:</p>
<blockquote>
<div><p>a list of cycles represented by their edge sets</p>
</div></blockquote>
</dd>
</dl>
<section id="raises">
<h4>Raises<a class="headerlink" href="#raises" title="Permalink to this heading">¶</a></h4>
<dl class="simple">
<dt>NotImplementedError</dt><dd><p>If no graph is initially set for the backbone Graph G.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="module-snarlpy.tangledGenerators">
<span id="snarlpy-tangledgenerators"></span><h2>snarlpy.tangledGenerators<a class="headerlink" href="#module-snarlpy.tangledGenerators" title="Permalink to this heading">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">snarlpy modules</a><ul>
<li><a class="reference internal" href="#module-snarlpy.cycle_sampling">snarlpy.cycle_sampling</a><ul>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.generate_networkx_cycle_from_edges"><code class="docutils literal notranslate"><span class="pre">generate_networkx_cycle_from_edges()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.generate_random_coordinate"><code class="docutils literal notranslate"><span class="pre">generate_random_coordinate()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.generate_random_index"><code class="docutils literal notranslate"><span class="pre">generate_random_index()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.get_binary"><code class="docutils literal notranslate"><span class="pre">get_binary()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.get_keyNumbers_forBinary"><code class="docutils literal notranslate"><span class="pre">get_keyNumbers_forBinary()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.get_new_cycle"><code class="docutils literal notranslate"><span class="pre">get_new_cycle()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.get_new_cycle_components"><code class="docutils literal notranslate"><span class="pre">get_new_cycle_components()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.get_new_cycle_components_gamma"><code class="docutils literal notranslate"><span class="pre">get_new_cycle_components_gamma()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.grab_all_cycles_from_space"><code class="docutils literal notranslate"><span class="pre">grab_all_cycles_from_space()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycle_sampling.grab_cycles_from_space"><code class="docutils literal notranslate"><span class="pre">grab_cycles_from_space()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-snarlpy.cycleToolsLinking">snarlpy.cycleToolsLinking</a><ul>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_extraTools"><code class="docutils literal notranslate"><span class="pre">linkedCycles_extraTools</span></code></a><ul>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_extraTools.compute_link_number"><code class="docutils literal notranslate"><span class="pre">linkedCycles_extraTools.compute_link_number()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_extraTools.gauss_map"><code class="docutils literal notranslate"><span class="pre">linkedCycles_extraTools.gauss_map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools</span></code></a><ul>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_cycleSets_nxGraph"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.calc_linkage_cycleSets_nxGraph()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_cycleSets_points3D"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.calc_linkage_cycleSets_points3D()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.calc_linkage_points3D"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.calc_linkage_points3D()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.compute_link_number"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.compute_link_number()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.extract_points_nxGraph"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.extract_points_nxGraph()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.gauss_map"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.gauss_map()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_geoInfo"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.get_geoInfo()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_curve"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.get_smooth_curve()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_director"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.get_smooth_director()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.get_smooth_points"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.get_smooth_points()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.cycleToolsLinking.linkedCycles_tools.refine_curve_points"><code class="docutils literal notranslate"><span class="pre">linkedCycles_tools.refine_curve_points()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-snarlpy.edge_algebra">snarlpy.edge_algebra</a><ul>
<li><a class="reference internal" href="#snarlpy.edge_algebra.calc_echelon_form"><code class="docutils literal notranslate"><span class="pre">calc_echelon_form()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.check_superposition_edge_connected"><code class="docutils literal notranslate"><span class="pre">check_superposition_edge_connected()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.edge_column"><code class="docutils literal notranslate"><span class="pre">edge_column()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.edge_column_binary"><code class="docutils literal notranslate"><span class="pre">edge_column_binary()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.edge_column_rand"><code class="docutils literal notranslate"><span class="pre">edge_column_rand()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.generate_edge_matrix"><code class="docutils literal notranslate"><span class="pre">generate_edge_matrix()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.generate_edge_matrix_binary"><code class="docutils literal notranslate"><span class="pre">generate_edge_matrix_binary()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.get_component_key"><code class="docutils literal notranslate"><span class="pre">get_component_key()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.get_cycle_superpositions_edge_vector"><code class="docutils literal notranslate"><span class="pre">get_cycle_superpositions_edge_vector()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.edge_algebra.sort_rows"><code class="docutils literal notranslate"><span class="pre">sort_rows()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-snarlpy.edgePriority">snarlpy.edgePriority</a></li>
<li><a class="reference internal" href="#snarlpy-edgeprioritycoarsesystem">snarlpy.edgePriorityCoarseSystem</a></li>
<li><a class="reference internal" href="#snarlpy-snarlpyness-randrobustness">snarlpy.snarlpyness_randRobustness</a></li>
<li><a class="reference internal" href="#module-snarlpy.sampling">snarlpy.sampling</a><ul>
<li><a class="reference internal" href="#snarlpy.sampling.calc_basisIntertwinedness"><code class="docutils literal notranslate"><span class="pre">calc_basisIntertwinedness()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.sampling.calc_basis_linkage"><code class="docutils literal notranslate"><span class="pre">calc_basis_linkage()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.sampling.calc_cycle_basis"><code class="docutils literal notranslate"><span class="pre">calc_cycle_basis()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.sampling.calc_cycle_minimum_basis"><code class="docutils literal notranslate"><span class="pre">calc_cycle_minimum_basis()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.sampling.calc_nullity"><code class="docutils literal notranslate"><span class="pre">calc_nullity()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.sampling.extract_linkage_matrix"><code class="docutils literal notranslate"><span class="pre">extract_linkage_matrix()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.sampling.get_basis_matrices"><code class="docutils literal notranslate"><span class="pre">get_basis_matrices()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-snarlpy.signature">snarlpy.signature</a><ul>
<li><a class="reference internal" href="#snarlpy.signature.extract_eulerpath"><code class="docutils literal notranslate"><span class="pre">extract_eulerpath()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.signature.get_edge_direction"><code class="docutils literal notranslate"><span class="pre">get_edge_direction()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.signature.get_relative_direction"><code class="docutils literal notranslate"><span class="pre">get_relative_direction()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.signature.get_signature"><code class="docutils literal notranslate"><span class="pre">get_signature()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.signature.get_signature_rand"><code class="docutils literal notranslate"><span class="pre">get_signature_rand()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-snarlpy.simpleCycles">snarlpy.simpleCycles</a><ul>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles"><code class="docutils literal notranslate"><span class="pre">simple_cycles</span></code></a><ul>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.breadth_first_tree"><code class="docutils literal notranslate"><span class="pre">simple_cycles.breadth_first_tree()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.compute_cycles_superlist"><code class="docutils literal notranslate"><span class="pre">simple_cycles.compute_cycles_superlist()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.compute_linear_independence"><code class="docutils literal notranslate"><span class="pre">simple_cycles.compute_linear_independence()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.compute_sprouts"><code class="docutils literal notranslate"><span class="pre">simple_cycles.compute_sprouts()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.construct_minimum_basis"><code class="docutils literal notranslate"><span class="pre">simple_cycles.construct_minimum_basis()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.construct_networkx_basis"><code class="docutils literal notranslate"><span class="pre">simple_cycles.construct_networkx_basis()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.construct_networkx_minimum_basis"><code class="docutils literal notranslate"><span class="pre">simple_cycles.construct_networkx_minimum_basis()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.edge_matrix"><code class="docutils literal notranslate"><span class="pre">simple_cycles.edge_matrix()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.extract_path_origin"><code class="docutils literal notranslate"><span class="pre">simple_cycles.extract_path_origin()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.find_cycle"><code class="docutils literal notranslate"><span class="pre">simple_cycles.find_cycle()</span></code></a></li>
<li><a class="reference internal" href="#snarlpy.simpleCycles.simple_cycles.generate_cycle_lists"><code class="docutils literal notranslate"><span class="pre">simple_cycles.generate_cycle_lists()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-snarlpy.tangledGenerators">snarlpy.tangledGenerators</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="intro.html"
                          title="previous chapter">Introduction</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/snarlpy.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">snarlpy  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">snarlpy modules</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Felix Kramer.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>